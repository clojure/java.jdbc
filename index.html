<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.java.jdbc - java.jdbc 0.7.13-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">java.jdbc API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">java.jdbc</span> <span id="version">0.7.13-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#proto-section">Protocols</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/IResultSetReadColumn" class="toc-entry-anchor">IResultSetReadColumn</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/result-set-read-column" class="toc-subentry-anchor">result-set-read-column</a>
      </div>
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/ISQLParameter" class="toc-entry-anchor">ISQLParameter</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/set-parameter" class="toc-subentry-anchor">set-parameter</a>
      </div>
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/ISQLValue" class="toc-entry-anchor">ISQLValue</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/sql-value" class="toc-subentry-anchor">sql-value</a>
      </div>
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/as-sql-name" class="toc-entry-anchor">as-sql-name</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/create-table-ddl" class="toc-entry-anchor">create-table-ddl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-connection" class="toc-entry-anchor">db-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-commands" class="toc-entry-anchor">db-do-commands</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-prepared" class="toc-entry-anchor">db-do-prepared</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-prepared-return-keys" class="toc-entry-anchor">db-do-prepared-return-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-find-connection" class="toc-entry-anchor">db-find-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-is-rollback-only" class="toc-entry-anchor">db-is-rollback-only</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-query-with-resultset" class="toc-entry-anchor">db-query-with-resultset</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-set-rollback-only!" class="toc-entry-anchor">db-set-rollback-only!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-transaction*" class="toc-entry-anchor">db-transaction*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-unset-rollback-only!" class="toc-entry-anchor">db-unset-rollback-only!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/delete!" class="toc-entry-anchor">delete!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/drop-table-ddl" class="toc-entry-anchor">drop-table-ddl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/execute!" class="toc-entry-anchor">execute!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/find-by-keys" class="toc-entry-anchor">find-by-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/get-by-id" class="toc-entry-anchor">get-by-id</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/get-connection" class="toc-entry-anchor">get-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/get-isolation-level" class="toc-entry-anchor">get-isolation-level</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/insert!" class="toc-entry-anchor">insert!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/insert-multi!" class="toc-entry-anchor">insert-multi!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/metadata-query" class="toc-entry-anchor">metadata-query</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/metadata-result" class="toc-entry-anchor">metadata-result</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/prepare-statement" class="toc-entry-anchor">prepare-statement</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-sql-exception" class="toc-entry-anchor">print-sql-exception</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-sql-exception-chain" class="toc-entry-anchor">print-sql-exception-chain</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-update-counts" class="toc-entry-anchor">print-update-counts</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/query" class="toc-entry-anchor">query</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/quoted" class="toc-entry-anchor">quoted</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/reducible-query" class="toc-entry-anchor">reducible-query</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/reducible-result-set" class="toc-entry-anchor">reducible-result-set</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/result-set-seq" class="toc-entry-anchor">result-set-seq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/update!" class="toc-entry-anchor">update!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-connection" class="toc-entry-anchor">with-db-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-metadata" class="toc-entry-anchor">with-db-metadata</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-transaction" class="toc-entry-anchor">with-db-transaction</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.java.jdbc.datafy">clojure.java.jdbc.datafy</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc.datafy/find-by-keys" class="toc-entry-anchor">find-by-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc.datafy/get-by-id" class="toc-entry-anchor">get-by-id</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc.datafy/query" class="toc-entry-anchor">query</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.java.jdbc.spec">clojure.java.jdbc.spec</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/as-arrays?" class="toc-entry-anchor">::as-arrays?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/auto-commit?" class="toc-entry-anchor">::auto-commit?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/classname" class="toc-entry-anchor">::classname</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/column-direction" class="toc-entry-anchor">::column-direction</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/column-spec" class="toc-entry-anchor">::column-spec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/concurrency" class="toc-entry-anchor">::concurrency</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/conditional?" class="toc-entry-anchor">::conditional?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/connection" class="toc-entry-anchor">::connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/connection-binding" class="toc-entry-anchor">::connection-binding</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/connection-options" class="toc-entry-anchor">::connection-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/connection-uri" class="toc-entry-anchor">::connection-uri</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/cursors" class="toc-entry-anchor">::cursors</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/datasource" class="toc-entry-anchor">::datasource</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec" class="toc-entry-anchor">::db-spec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-connection" class="toc-entry-anchor">::db-spec-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-data-source" class="toc-entry-anchor">::db-spec-data-source</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-driver-manager" class="toc-entry-anchor">::db-spec-driver-manager</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-factory" class="toc-entry-anchor">::db-spec-factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-friendly" class="toc-entry-anchor">::db-spec-friendly</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-jndi" class="toc-entry-anchor">::db-spec-jndi</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-raw" class="toc-entry-anchor">::db-spec-raw</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-string" class="toc-entry-anchor">::db-spec-string</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/db-spec-uri" class="toc-entry-anchor">::db-spec-uri</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/dbname" class="toc-entry-anchor">::dbname</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/dbtype" class="toc-entry-anchor">::dbtype</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/delimiter" class="toc-entry-anchor">::delimiter</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/direction" class="toc-entry-anchor">::direction</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/entities" class="toc-entry-anchor">::entities</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/entity" class="toc-entry-anchor">::entity</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/environment" class="toc-entry-anchor">::environment</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/exec-sql-options" class="toc-entry-anchor">::exec-sql-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/execute-options" class="toc-entry-anchor">::execute-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/execute-result" class="toc-entry-anchor">::execute-result</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/explain-fn" class="toc-entry-anchor">::explain-fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/explain?" class="toc-entry-anchor">::explain?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/factory" class="toc-entry-anchor">::factory</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/fetch-size" class="toc-entry-anchor">::fetch-size</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/find-by-keys-options" class="toc-entry-anchor">::find-by-keys-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/host" class="toc-entry-anchor">::host</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/identifier" class="toc-entry-anchor">::identifier</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/identifiers" class="toc-entry-anchor">::identifiers</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/isolation" class="toc-entry-anchor">::isolation</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/keywordize?" class="toc-entry-anchor">::keywordize?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/max-size" class="toc-entry-anchor">::max-size</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/multi?" class="toc-entry-anchor">::multi?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/name" class="toc-entry-anchor">::name</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/naming-strategy" class="toc-entry-anchor">::naming-strategy</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/order-by" class="toc-entry-anchor">::order-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/password" class="toc-entry-anchor">::password</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/port" class="toc-entry-anchor">::port</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/prepare-options" class="toc-entry-anchor">::prepare-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/prepared-statement" class="toc-entry-anchor">::prepared-statement</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/qualifier" class="toc-entry-anchor">::qualifier</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/query-options" class="toc-entry-anchor">::query-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/read-columns" class="toc-entry-anchor">::read-columns</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/read-only?" class="toc-entry-anchor">::read-only?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/reducible-query-options" class="toc-entry-anchor">::reducible-query-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/result-set" class="toc-entry-anchor">::result-set</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/result-set-fn" class="toc-entry-anchor">::result-set-fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/result-set-metadata" class="toc-entry-anchor">::result-set-metadata</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/result-type" class="toc-entry-anchor">::result-type</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/return-keys" class="toc-entry-anchor">::return-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/row-fn" class="toc-entry-anchor">::row-fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/sql-params" class="toc-entry-anchor">::sql-params</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/sql-stmt" class="toc-entry-anchor">::sql-stmt</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/sql-value" class="toc-entry-anchor">::sql-value</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/subname" class="toc-entry-anchor">::subname</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/subprotocol" class="toc-entry-anchor">::subprotocol</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/subprotocol-alias" class="toc-entry-anchor">::subprotocol-alias</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/subprotocol-base" class="toc-entry-anchor">::subprotocol-base</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/table-spec" class="toc-entry-anchor">::table-spec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/timeout" class="toc-entry-anchor">::timeout</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/transaction-binding" class="toc-entry-anchor">::transaction-binding</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/transaction-options" class="toc-entry-anchor">::transaction-options</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/transaction?" class="toc-entry-anchor">::transaction?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/uri" class="toc-entry-anchor">::uri</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/user" class="toc-entry-anchor">::user</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/username" class="toc-entry-anchor">::username</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#:clojure.java.jdbc.spec/where-clause" class="toc-entry-anchor">::where-clause</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.java.jdbc">clojure.java.jdbc</span>
  - <span id="header-project">java.jdbc</span> <span id="header-version">0.7.13-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">Stephen C. Gilardi, Sean Corfield</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.java.jdbc</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/java.jdbc/">https://github.com/clojure/java.jdbc/</a></div>
<pre id="namespace-docstr">A Clojure interface to SQL databases via JDBC

clojure.java.jdbc provides a simple abstraction for CRUD (create, read,
update, delete) operations on a SQL database, along with basic transaction
support. Basic DDL operations are also supported (create table, drop table,
access to table metadata).

Maps are used to represent records, making it easy to store and retrieve
data. Results can be processed using any standard sequence operations.

For most operations, Java's PreparedStatement is used so your SQL and
parameters can be represented as simple vectors where the first element
is the SQL string, with ? for each parameter, and the remaining elements
are the parameter values to be substituted.

For more documentation, see:

<a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html</a></pre>


<br />

<div id="proto-section">
  <p></p>
  <h2>Protocols</h2>
  <div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/IResultSetReadColumn">IResultSetReadColumn</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for reading objects from the java.sql.ResultSet. Default
implementations (for Object and nil) return the argument, and the
Boolean implementation ensures a canonicalized true/false value,
but it can be extended to provide custom behavior for special types.</pre>
    Known implementations: <span id="proto-impls">java.lang.Boolean, nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/result-set-read-column">result-set-read-column</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (result-set-read-column val rsmeta idx)
</pre>
      <pre id="var-docstr">Function for transforming values after reading them from the database</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L498">Source</a>
  </div><div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/ISQLParameter">ISQLParameter</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for setting SQL parameters in statement objects, which
can convert from Clojure values. The default implementation just
delegates the conversion to ISQLValue's sql-value conversion and
uses .setObject on the parameter. It can be extended to use other
methods of PreparedStatement to convert and set parameter values.</pre>
    Known implementations: <span id="proto-impls">nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/set-parameter">set-parameter</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (set-parameter val stmt ix)
</pre>
      <pre id="var-docstr">Convert a Clojure value into a SQL value and store it as the ix'th
parameter in the given SQL statement object.</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L471">Source</a>
  </div><div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/ISQLValue">ISQLValue</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for creating SQL values from Clojure values. Default
implementations (for Object and nil) just return the argument,
but it can be extended to provide custom behavior to support
exotic types supported by different databases.</pre>
    Known implementations: <span id="proto-impls">nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/sql-value">sql-value</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (sql-value val)
</pre>
      <pre id="var-docstr">Convert a Clojure value into a SQL value.</pre>
      <pre id="var-specs"></pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L457">Source</a>
  </div>
</div>

<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/as-sql-name">as-sql-name</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (as-sql-name f x)
</pre>
    <pre id="var-docstr">Given a naming strategy function and a keyword or string, return
a string per that naming strategy.
A name of the form x.y is treated as multiple names, x, y, etc,
and each are turned into strings via the naming strategy and then
joined back together so x.y might become `x`.`y` if the naming
strategy quotes identifiers with `.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :f :clojure.java.jdbc.spec/naming-strategy
         :x :clojure.java.jdbc.spec/identifier)
  Ret:  (or :kw keyword? :s string?)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L53">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/create-table-ddl">create-table-ddl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (create-table-ddl table specs)
       (create-table-ddl table specs opts)
</pre>
    <pre id="var-docstr">Given a table name and a vector of column specs, return the DDL string for
creating that table. Each column spec is, in turn, a vector of keywords or
strings that is converted to strings and concatenated with spaces to form
a single column description in DDL, e.g.,
  [:cost :int "not null"]
  [:name "varchar(32)"]
The first element of a column spec is treated as a SQL entity (so if you
provide the :entities option, that will be used to transform it). The
remaining elements are left as-is when converting them to strings.
An options map may be provided that can contain:
:table-spec -- a string that is appended to the DDL -- and/or
:entities -- a function to specify how column names are transformed.
:conditional? -- either a boolean, indicating whether to add 'IF NOT EXISTS',
  or a string, which is inserted literally before the table name, or a
  function of two arguments (table name and the create statement), that can
  manipulate the generated statement to better support other databases, e.g.,
  MS SQL Server which need to wrap create table in an existence query.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :table :clojure.java.jdbc.spec/identifier
         :specs (coll-of :clojure.java.jdbc.spec/column-spec)
         :opts (?
                 (keys
                  :req-un []
                  :opt-un [:clojure.java.jdbc.spec/entities
                           :clojure.java.jdbc.spec/conditional?
                           :clojure.java.jdbc.spec/table-spec])))
  Ret:  string?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1688">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-connection">db-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-connection db)
</pre>
    <pre id="var-docstr">Returns the current database connection (or throws if there is none)</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db-spec :clojure.java.jdbc.spec/db-spec)
  Ret:  (instance? java.sql.Connection %)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L731">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-commands">db-do-commands</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-commands db sql-commands)
       (db-do-commands db transaction? sql-commands)
</pre>
    <pre id="var-docstr">Executes SQL commands on the specified database connection. Wraps the commands
in a transaction if transaction? is true. transaction? can be omitted and it
defaults to true. Accepts a single SQL command (string) or a vector of them.
Uses executeBatch. This may affect what SQL you can run via db-do-commands.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :transaction? (? boolean?)
         :sql-commands (or
                        :command string?
                        :commands (coll-of string?)))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L942">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-prepared">db-do-prepared</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-prepared db sql-params)
       (db-do-prepared db transaction? sql-params)
       (db-do-prepared db transaction? sql-params opts)
</pre>
    <pre id="var-docstr">Executes an (optionally parameterized) SQL prepared statement on the
open database connection. Each param-group is a seq of values for all of
the parameters. transaction? can be omitted and defaults to true.
The sql parameter can either be a SQL string or a PreparedStatement.
Return a seq of update counts (one count for each param-group).</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :transaction? (? boolean?)
         :sql-params :clojure.java.jdbc.spec/sql-params
         :opts (?
                 (merge
                   :clojure.java.jdbc.spec/execute-options
                   :clojure.java.jdbc.spec/query-options)))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1060">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-prepared-return-keys">db-do-prepared-return-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-prepared-return-keys db sql-params)
       (db-do-prepared-return-keys db transaction? sql-params)
       (db-do-prepared-return-keys db transaction? sql-params opts)
</pre>
    <pre id="var-docstr">Executes an (optionally parameterized) SQL prepared statement on the
open database connection. The param-group is a seq of values for all of
the parameters. transaction? can be omitted and will default to true.
Return the generated keys for the (single) update/insert.
A PreparedStatement may be passed in, instead of a SQL string, in which
case :return-keys MUST BE SET on that PreparedStatement!</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :transaction? (? boolean?)
         :sql-params :clojure.java.jdbc.spec/sql-params
         :opts (?
                 (merge
                   :clojure.java.jdbc.spec/execute-options
                   :clojure.java.jdbc.spec/query-options)))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1015">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-find-connection">db-find-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-find-connection db)
</pre>
    <pre id="var-docstr">Returns the current database connection (or nil if there is none)</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db-spec :clojure.java.jdbc.spec/db-spec)
  Ret:  (nilable :clojure.java.jdbc.spec/connection)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L725">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-is-rollback-only">db-is-rollback-only</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-is-rollback-only db)
</pre>
    <pre id="var-docstr">Returns true if the outermost transaction will rollback rather than
commit when complete</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db :clojure.java.jdbc.spec/db-spec)
  Ret:  boolean?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L748">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-query-with-resultset">db-query-with-resultset</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-query-with-resultset db sql-params func)
       (db-query-with-resultset db sql-params func opts)
</pre>
    <pre id="var-docstr">Executes a query, then evaluates func passing in the raw ResultSet as an
 argument. The second argument is a vector containing either:
  [sql &amp; params] - a SQL query, followed by any parameters it needs
  [stmt &amp; params] - a PreparedStatement, followed by any parameters it needs
                    (the PreparedStatement already contains the SQL query)
The opts map is passed to prepare-statement.
Uses executeQuery. This may affect what SQL you can run via query.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :sql-params :clojure.java.jdbc.spec/sql-params
         :func ifn?
         :opts (? :clojure.java.jdbc.spec/query-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1119">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-set-rollback-only!">db-set-rollback-only!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-set-rollback-only! db)
</pre>
    <pre id="var-docstr">Marks the outermost transaction such that it will rollback rather than
commit when complete</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db :clojure.java.jdbc.spec/db-spec)
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L737">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-transaction*">db-transaction*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-transaction* db func)
       (db-transaction* db func opts)
</pre>
    <pre id="var-docstr">Evaluates func as a transaction on the open database connection. Any
nested transactions are absorbed into the outermost transaction. By
default, all database updates are committed together as a group after
evaluating the outermost body, or rolled back on any uncaught
exception. If rollback is set within scope of the outermost transaction,
the entire transaction will be rolled back rather than committed when
complete.
The isolation option may be :none, :read-committed, :read-uncommitted,
:repeatable-read, or :serializable. Note that not all databases support
all of those isolation levels, and may either throw an exception or
substitute another isolation level.
The read-only? option puts the transaction in readonly mode (if supported).</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :func ifn?
         :opts (? :clojure.java.jdbc.spec/transaction-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L776">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-unset-rollback-only!">db-unset-rollback-only!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-unset-rollback-only! db)
</pre>
    <pre id="var-docstr">Marks the outermost transaction such that it will not rollback when complete</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db :clojure.java.jdbc.spec/db-spec)
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L743">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/delete!">delete!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (delete! db table where-clause)
       (delete! db table where-clause opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name and a where clause of columns to match,
perform a delete. The options may specify how to transform column names in the
map (default 'as-is') and whether to run the delete in a transaction (default true).
Example:
  (delete! db :person ["zip = ?" 94546])
is equivalent to:
  (execute! db ["DELETE FROM person WHERE zip = ?" 94546])</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :table :clojure.java.jdbc.spec/identifier
         :where-clause (spec :clojure.java.jdbc.spec/where-clause)
         :opts (? :clojure.java.jdbc.spec/exec-sql-options))
  Ret:  (* integer?)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1479">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/drop-table-ddl">drop-table-ddl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (drop-table-ddl table)
       (drop-table-ddl table {:keys [entities conditional?], :or {entities identity}})
</pre>
    <pre id="var-docstr">Given a table name, return the DDL string for dropping that table.
An options map may be provided that can contain:
:entities -- a function to specify how column names are transformed.
:conditional? -- either a boolean, indicating whether to add 'IF EXISTS',
  or a string, which is inserted literally before the table name, or a
  function of two arguments (table name and the create statement), that can
  manipulate the generated statement to better support other databases, e.g.,
  MS SQL Server which need to wrap create table in an existence query.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :table :clojure.java.jdbc.spec/identifier
         :opts (?
                 (keys
                  :req-un []
                  :opt-un [:clojure.java.jdbc.spec/entities
                           :clojure.java.jdbc.spec/conditional?])))
  Ret:  string?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1734">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/execute!">execute!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (execute! db sql-params)
       (execute! db sql-params opts)
</pre>
    <pre id="var-docstr">Given a database connection and a vector containing SQL (or PreparedStatement)
followed by optional parameters, perform a general (non-select) SQL operation.

The :transaction? option specifies whether to run the operation in a
transaction or not (default true).

If the :multi? option is false (the default), the SQL statement should be
followed by the parameters for that statement.

If the :multi? option is true, the SQL statement should be followed by one or
more vectors of parameters, one for each application of the SQL statement.

If :return-keys is provided, db-do-prepared-return-keys will be called
instead of db-do-prepared, and the result will be a sequence of maps
containing the generated keys. If present, :row-fn will be applied. If :multi?
then :result-set-fn will also be applied if present. :as-arrays? may also be
specified (which will affect what :result-set-fn is passed).

If there are no parameters specified, executeUpdate will be used, otherwise
executeBatch will be used. This may affect what SQL you can run via execute!</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :sql-params :clojure.java.jdbc.spec/sql-params
         :opts (? :clojure.java.jdbc.spec/execute-options))
  Ret:  (or
         :rows :clojure.java.jdbc.spec/execute-result
         :keys (coll-of map?))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1435">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/find-by-keys">find-by-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (find-by-keys db table columns)
       (find-by-keys db table columns opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a map of column name/value
pairs, and an optional options map, return any matching rows.

An :order-by option may be supplied to sort the rows, e.g.,

    {:order-by [{:name :asc} {:age :desc} {:income :asc}]}
    ;; equivalent to:
    {:order-by [:name {:age :desc} :income]}

The :order-by value is a sequence of column names (to sort in ascending
order) and/or maps from column names to directions (:asc or :desc). The
directions may be strings or keywords and are not case-sensitive. They
are mapped to ASC or DESC in the generated SQL.

Note: if a ordering map has more than one key, the order of the columns
in the generated SQL ORDER BY clause is unspecified (so such maps should
only contain one key/value pair).</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :table :clojure.java.jdbc.spec/identifier
         :columns (map-of
                    :clojure.java.jdbc.spec/identifier
                    :clojure.java.jdbc.spec/sql-value)
         :opts (? :clojure.java.jdbc.spec/find-by-keys-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1386">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/get-by-id">get-by-id</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-by-id db table pk-value)
       (get-by-id db table pk-value pk-name-or-opts)
       (get-by-id db table pk-value pk-name opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a primary key value, an
optional primary key column name, and an optional options map, return
a single matching row, or nil.
The primary key column name defaults to :id.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :table :clojure.java.jdbc.spec/identifier
         :pk-value :clojure.java.jdbc.spec/sql-value
         :opt-args (cat
                    :pk-name (? :clojure.java.jdbc.spec/identifier)
                    :opts (?
                            :clojure.java.jdbc.spec/find-by-keys-options)))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1419">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/get-connection">get-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-connection db-spec)
       (get-connection {:keys [connection factory connection-uri classname subprotocol subname dbtype dbname host port datasource username password user name environment], :as db-spec} opts)
</pre>
    <pre id="var-docstr">Creates a connection to a database. db-spec is usually a map containing connection
parameters but can also be a URI or a String.

The only time you should call this function is when you need a Connection for
prepare-statement -- no other public functions in clojure.java.jdbc accept a
raw Connection object: they all expect a db-spec (either a raw db-spec or one
obtained via with-db-connection or with-db-transaction).

The correct usage of get-connection for prepare-statement is:

    (with-open [conn (jdbc/get-connection db-spec)]
      ... (jdbc/prepare-statement conn sql-statement options) ...)

Any connection obtained via calling get-connection directly must be closed
explicitly (via with-open or a direct call to .close on the Connection object).

The various possibilities are described below:

DriverManager (preferred):
  :dbtype      (required) a String, the type of the database (the jdbc subprotocol)
  :dbname      (required) a String, the name of the database
  :classname   (optional) a String, the jdbc driver class name
  :host        (optional) a String, the host name/IP of the database
                          (defaults to 127.0.0.1)
  :port        (optional) a Long, the port of the database
                          (defaults to 3306 for mysql, 1433 for mssql/jtds, else nil)
  (others)     (optional) passed to the driver as properties
                          (may include :user and :password)

Raw:
  :connection-uri (required) a String
               Passed directly to DriverManager/getConnection
               (both :user and :password may be specified as well, rather
                than passing them as part of the connection string)

Other formats accepted:

Existing Connection:
  :connection  (required) an existing open connection that can be used
               but cannot be closed (only the parent connection can be closed)

DriverManager (alternative / legacy style):
  :subprotocol (required) a String, the jdbc subprotocol
  :subname     (required) a String, the jdbc subname
  :classname   (optional) a String, the jdbc driver class name
  (others)     (optional) passed to the driver as properties
                          (may include :user and :password)

Factory:
  :factory     (required) a function of one argument, a map of params
  (others)     (optional) passed to the factory function in a map

DataSource:
  :datasource  (required) a javax.sql.DataSource
  :username    (optional) a String - deprecated, use :user instead
  :user        (optional) a String - preferred
  :password    (optional) a String, required if :user is supplied

JNDI:
  :name        (required) a String or javax.naming.Name
  :environment (optional) a java.util.Map

java.net.URI:
  Parsed JDBC connection string (see java.lang.String format next)

java.lang.String:
  subprotocol://user:password@host:post/subname
               An optional prefix of jdbc: is allowed.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db-spec :clojure.java.jdbc.spec/db-spec
         :opts (? :clojure.java.jdbc.spec/connection-options))
  Ret:  (instance? java.sql.Connection %)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L274">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/get-isolation-level">get-isolation-level</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-isolation-level db)
</pre>
    <pre id="var-docstr">Given a db-spec (with an optional connection), return the current
transaction isolation level, if known. Return nil if there is no
active connection in the db-spec. Return :unknown if we do not
recognize the isolation level.</pre>
    <pre id="var-specs">Specs:
  Args: (cat :db :clojure.java.jdbc.spec/db-spec)
  Ret:  (nilable
          (or
           :isolation :clojure.java.jdbc.spec/isolation
           :unknown #{:unknown}))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L767">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/insert!">insert!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (insert! db table row)
       (insert! db table cols-or-row values-or-opts)
       (insert! db table cols values opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name and either a map representing a rows,
or a list of column names followed by a list of column values also representing
a single row, perform an insert.
When inserting a row as a map, the result is the database-specific form of the
generated keys, if available (note: PostgreSQL returns the whole row).
When inserting a row as a list of column values, the result is the count of
rows affected (1), if available (from getUpdateCount after executeBatch).
The row map or column value vector may be followed by a map of options:
The :transaction? option specifies whether to run in a transaction or not.
The default is true (use a transaction). The :entities option specifies how
to convert the table name and column names to SQL entities.</pre>
    <pre id="var-specs">Specs:
  Args: (or
         :row (cat
               :db :clojure.java.jdbc.spec/db-spec
               :table :clojure.java.jdbc.spec/identifier
               :row (map-of :clojure.java.jdbc.spec/identifier any?)
               :opts (?
                       (merge
                         :clojure.java.jdbc.spec/execute-options
                         :clojure.java.jdbc.spec/query-options)))
         :cvs (cat
               :db :clojure.java.jdbc.spec/db-spec
               :table :clojure.java.jdbc.spec/identifier
               :cols (nilable
                       (coll-of :clojure.java.jdbc.spec/identifier))
               :vals (coll-of any?)
               :opts (?
                       (merge
                         :clojure.java.jdbc.spec/execute-options
                         :clojure.java.jdbc.spec/query-options))))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1599">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/insert-multi!">insert-multi!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (insert-multi! db table rows)
       (insert-multi! db table cols-or-rows values-or-opts)
       (insert-multi! db table cols values opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name and either a sequence of maps (for
rows) or a sequence of column names, followed by a sequence of vectors (for
the values in each row), and possibly a map of options, insert that data into
the database.

When inserting rows as a sequence of maps, the result is a sequence of the
generated keys, if available (note: PostgreSQL returns the whole rows). A
separate database operation is used for each row inserted. This may be slow
for if a large sequence of maps is provided.

When inserting rows as a sequence of lists of column values, the result is
a sequence of the counts of rows affected (a sequence of 1's), if available.
Yes, that is singularly unhelpful. Thank you getUpdateCount and executeBatch!
A single database operation should be used to insert all the rows at once.
This may be much faster than inserting a sequence of rows (which performs an
insert for each map in the sequence).

Note: some database drivers need to be told to rewrite the SQL for this to
be performed as a single, batched operation. In particular, PostgreSQL
requires :reWriteBatchedInserts true and My SQL requires
:rewriteBatchedStatement true (both non-standard JDBC options, of course!).
These options should be passed into the driver when the connection is
created (however that is done in your program).

The :transaction? option specifies whether to run in a transaction or not.
The default is true (use a transaction). The :entities option specifies how
to convert the table name and column names to SQL entities.</pre>
    <pre id="var-specs">Specs:
  Args: (or
         :rows (cat
                :db :clojure.java.jdbc.spec/db-spec
                :table :clojure.java.jdbc.spec/identifier
                :rows (coll-of
                        (map-of
                          :clojure.java.jdbc.spec/identifier
                          any?))
                :opts (?
                        (merge
                          :clojure.java.jdbc.spec/execute-options
                          :clojure.java.jdbc.spec/query-options)))
         :cvs (cat
               :db :clojure.java.jdbc.spec/db-spec
               :table :clojure.java.jdbc.spec/identifier
               :cols (nilable
                       (coll-of :clojure.java.jdbc.spec/identifier))
               :vals (coll-of (coll-of any?))
               :opts (?
                       (merge
                         :clojure.java.jdbc.spec/execute-options
                         :clojure.java.jdbc.spec/query-options))))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1619">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/metadata-query">metadata-query</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (metadata-query meta-query &amp; opt-args)
</pre>
    <pre id="var-docstr">Given a Java expression that extracts metadata (in the context of with-db-metadata),
and a map of options like metadata-result, manage the connection for a single
metadata-based query. Example usage:

(with-db-metadata [meta db-spec]
  (metadata-query (.getTables meta nil nil nil (into-array String ["TABLE"]))
    {:row-fn ... :result-set-fn ...}))</pre>
    <pre id="var-specs">Specs:
  Args: (cat :meta-query any? :opt-args (? any?))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L930">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/metadata-result">metadata-result</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (metadata-result rs-or-value)
       (metadata-result rs-or-value opts)
</pre>
    <pre id="var-docstr">If the argument is a java.sql.ResultSet, turn it into a result-set-seq,
else return it as-is. This makes working with metadata easier.
Also accepts an option map containing :identifiers, :keywordize?, :qualifier,
:as-arrays?, :row-fn, and :result-set-fn to control how the ResultSet is
transformed and returned. See query for more details.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :rs-or-value any?
         :opts (? :clojure.java.jdbc.spec/query-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L918">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/prepare-statement">prepare-statement</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (prepare-statement con sql)
       (prepare-statement con sql {:keys [return-keys result-type concurrency cursors fetch-size max-rows timeout]})
</pre>
    <pre id="var-docstr">Create a prepared statement from a connection, a SQL string and a map
of options:
   :return-keys truthy | nil - default nil
     for some drivers, this may be a vector of column names to identify
     the generated keys to return, otherwise it should just be true
   :result-type :forward-only | :scroll-insensitive | :scroll-sensitive
   :concurrency :read-only | :updatable
   :cursors     :hold | :close
   :fetch-size  n
   :max-rows    n
   :timeout     n
Note that :result-type and :concurrency must be specified together as the
underlying Java API expects both (or neither).</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :con :clojure.java.jdbc.spec/connection
         :sql string?
         :opts (? :clojure.java.jdbc.spec/prepare-options))
  Ret:  (instance? java.sql.PreparedStatement %)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L626">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-sql-exception">print-sql-exception</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-sql-exception exception)
</pre>
    <pre id="var-docstr">Prints the contents of an SQLException to *out*</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L685">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-sql-exception-chain">print-sql-exception-chain</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-sql-exception-chain exception)
</pre>
    <pre id="var-docstr">Prints a chain of SQLExceptions to *out*</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L699">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-update-counts">print-update-counts</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-update-counts exception)
</pre>
    <pre id="var-docstr">Prints the update counts from a BatchUpdateException to *out*</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L711">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/query">query</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (query db sql-params)
       (query db sql-params opts)
</pre>
    <pre id="var-docstr">Given a database connection and a vector containing SQL and optional parameters,
perform a simple database query. The options specify how to construct the result
set (and are also passed to prepare-statement as needed):
  :as-arrays? - return the results as a set of arrays, default false.
  :identifiers - applied to each column name in the result set, default lower-case
  :keywordize? - defaults to true, can be false to opt-out of converting
      identifiers to keywords
  :qualifier - optionally provides the namespace qualifier for identifiers
  :result-set-fn - applied to the entire result set, default doall / vec
      if :as-arrays? true, :result-set-fn will default to vec
      if :as-arrays? false, :result-set-fn will default to doall
  :row-fn - applied to each row as the result set is constructed, default identity
The second argument is a vector containing a SQL string or PreparedStatement, followed
by any parameters it needs.
See also prepare-statement for additional options.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :sql-params :clojure.java.jdbc.spec/sql-params
         :opts (?
                 (merge
                   :clojure.java.jdbc.spec/query-options
                   (keys
                    :req-un []
                    :opt-un [:clojure.java.jdbc.spec/explain?
                             :clojure.java.jdbc.spec/explain-fn]))))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1144">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/quoted">quoted</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (quoted q)
</pre>
    <pre id="var-docstr">Given a (vector) pair of delimiters (characters or strings), return a naming
strategy function that will quote SQL entities with them.
Given a single delimiter, treat it as a (vector) pair of that delimiter.
  ((quoted [\[ \]]) "foo") will return "[foo]" -- for MS SQL Server
  ((quoted \`') "foo") will return "`foo`" -- for MySQL
Intended to be used with :entities to provide a quoting (naming) strategy that
is appropriate for your database.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :q (or
             :pair (coll-of
                     :clojure.java.jdbc.spec/delimiter
                     :kind
                     vector?
                     :count
                     2)
             :delimiter :clojure.java.jdbc.spec/delimiter
             :dialect #{:oracle :ansi :mysql :sqlserver}))
  Ret:  (fspec
          :args
          (cat :x :clojure.java.jdbc.spec/identifier)
          :ret
          :clojure.java.jdbc.spec/identifier
          :fn
          nil)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L67">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/reducible-query">reducible-query</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reducible-query db sql-params)
       (reducible-query db sql-params opts)
</pre>
    <pre id="var-docstr">Given a database connection, a vector containing SQL and optional parameters,
return a reducible collection. When reduced, it will start the database query
and reduce the result set, and then close the connection:
  (transduce (map :cost) + (reducible-query db sql-params))

The following options from query etc are not accepted here:
  :as-arrays? :explain :explain-fn :result-set-fn :row-fn
See prepare-statement for additional options that may be passed through.

If :raw? true is specified, the rows of the result set are not converted to
hash maps, and it as if the following options were specified:
  :identifiers identity :keywordize? false :qualifier nil
In addition, the rows of the result set may only be read as if they were hash
maps (get, keyword lookup, select-keys) but the sequence representation is
not available (so, no keys, no vals, and no seq calls). This is much faster
than converting each row to a hash map but it is also more restrictive.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :sql-params :clojure.java.jdbc.spec/sql-params
         :opts (? :clojure.java.jdbc.spec/reducible-query-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1313">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/reducible-result-set">reducible-result-set</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reducible-result-set rs {:keys [identifiers keywordize? qualifier read-columns], :or {identifiers lower-case, keywordize? true, read-columns dft-read-columns}})
</pre>
    <pre id="var-docstr">Given a java.sql.ResultSet return a reducible collection.
Compiled with Clojure 1.7 or later -- uses clojure.lang.IReduce
Note: :as-arrays? is not accepted here.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :rs :clojure.java.jdbc.spec/result-set
         :opts (? :clojure.java.jdbc.spec/reducible-query-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1229">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/result-set-seq">result-set-seq</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (result-set-seq rs)
       (result-set-seq rs {:keys [as-arrays? identifiers keywordize? qualifier read-columns], :or {identifiers lower-case, keywordize? true, read-columns dft-read-columns}})
</pre>
    <pre id="var-docstr">Creates and returns a lazy sequence of maps corresponding to the rows in the
java.sql.ResultSet rs. Loosely based on clojure.core/resultset-seq but it
respects the specified naming strategy. Duplicate column names are made unique
by appending _N before applying the naming strategy (where N is a unique integer),
unless the :as-arrays? option is :cols-as-is, in which case the column names
are untouched (the result set maintains column name/value order).
The :identifiers option specifies how SQL column names are converted to Clojure
keywords. The default is to convert them to lower case.
The :keywordize? option can be specified as false to opt-out of the conversion
to keywords.
The :qualifier option specifies the namespace qualifier for those identifiers
(and this may not be specified when :keywordize? is false).</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :rs :clojure.java.jdbc.spec/result-set
         :opts (? :clojure.java.jdbc.spec/query-options))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L545">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/update!">update!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update! db table set-map where-clause)
       (update! db table set-map where-clause opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a map of column values to set and a
where clause of columns to match, perform an update. The options may specify
how column names (in the set / match maps) should be transformed (default
'as-is') and whether to run the update in a transaction (default true).
Example:
  (update! db :person {:zip 94540} ["zip = ?" 94546])
is equivalent to:
  (execute! db ["UPDATE person SET zip = ? WHERE zip = ?" 94540 94546])</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :db :clojure.java.jdbc.spec/db-spec
         :table :clojure.java.jdbc.spec/identifier
         :set-map (map-of
                    :clojure.java.jdbc.spec/identifier
                    :clojure.java.jdbc.spec/sql-value)
         :where-clause (spec :clojure.java.jdbc.spec/where-clause)
         :opts (? :clojure.java.jdbc.spec/exec-sql-options))
  Ret:  (* integer?)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L1673">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-connection">with-db-connection</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-connection binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of an active connection to the database.
(with-db-connection [con-db db-spec opts]
  ... con-db ...)</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :binding :clojure.java.jdbc.spec/connection-binding
         :body (* any?))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L876">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-metadata">with-db-metadata</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-metadata binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of an active connection with metadata bound
to the specified name. See also metadata-result for dealing with the results
of operations that retrieve information from the metadata.
(with-db-metadata [md db-spec opts]
  ... md ...)</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :binding :clojure.java.jdbc.spec/connection-binding
         :body (* any?))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L889">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-transaction">with-db-transaction</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-transaction binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of a transaction on the specified database connection.
The binding provides the database connection for the transaction and the name to which
that is bound for evaluation of the body. The binding may also specify the isolation
level for the transaction, via the :isolation option and/or set the transaction to
readonly via the :read-only? option.
(with-db-transaction [t-con db-spec {:isolation level :read-only? true}]
  ... t-con ...)
See db-transaction* for more details.</pre>
    <pre id="var-specs">Specs:
  Args: (cat
         :binding :clojure.java.jdbc.spec/transaction-binding
         :body (* any?))
  Ret:  any?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/21512f86a1abd0a42e2174b7239329af6e3c9d9e/src/main/clojure/clojure/java/jdbc.clj#L862">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.java.jdbc.datafy">clojure.java.jdbc.datafy</h2>
<pre id="namespace-docstr">Variants of 'query' functions from clojure.java.jdbc that support
the new clojure.datafy functionality in Clojure 1.10.

The whole schema/column lookup piece is very likely to change!

Currently, the :schema option for a 'query' function is a mapping
from column name to a tuple of table name, key column, and optionally
the cardinality (:one -- the default -- or :many). The cardinality
determines whether navigation should produce a single row (hash map)
or a result set.

One of the problems is that the general case -- query -- doesn't
have any concept of an associated table name (and may of course
join across multiple tables), so there's no good way to take the
table name into account when mapping a column to another table.

For find-by-keys and get-by-id, you do have the starting table
name so you could map [table1 column1] to [table2 column2] and have
table-specific mappings.

The obvious, logical thing would be to use SQL metadata to figure
out actual foreign key constraints but not everyone uses them, for
a variety of reasons. For folks who do use them, they can build
their schema structure from the database, and pass the relevant
part of it to the functions below (via :schema in options).</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc.datafy/find-by-keys">find-by-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (find-by-keys db table columns)
       (find-by-keys db table columns opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a map of column name/value
pairs, and an optional options map, return any matching rows.

An :order-by option may be supplied to sort the rows, e.g.,

    {:order-by [{:name :asc} {:age :desc} {:income :asc}]}
    ;; equivalent to:
    {:order-by [:name {:age :desc} :income]}

The :order-by value is a sequence of column names (to sort in ascending
order) and/or maps from column names to directions (:asc or :desc). The
directions may be strings or keywords and are not case-sensitive. They
are mapped to ASC or DESC in the generated SQL.

Note: if a ordering map has more than one key, the order of the columns
in the generated SQL ORDER BY clause is unspecified (so such maps should
only contain one key/value pair).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/79ad004b42e9234d2bbf54df6a254c22b1c68c72/src/main/clojure/clojure/java/jdbc/datafy.clj#L119">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc.datafy/get-by-id">get-by-id</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-by-id db table pk-value)
       (get-by-id db table pk-value pk-name-or-opts)
       (get-by-id db table pk-value pk-name opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a primary key value, an
optional primary key column name, and an optional options map, return
a single matching row, or nil.
The primary key column name defaults to :id.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/79ad004b42e9234d2bbf54df6a254c22b1c68c72/src/main/clojure/clojure/java/jdbc/datafy.clj#L105">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc.datafy/query">query</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (query db sql-params)
       (query db sql-params opts)
</pre>
    <pre id="var-docstr">Given a database connection and a vector containing SQL and optional parameters,
perform a simple database query. The options specify how to construct the result
set (and are also passed to prepare-statement as needed):
  :as-arrays? - return the results as a set of arrays, default false.
  :identifiers - applied to each column name in the result set, default lower-case
  :keywordize? - defaults to true, can be false to opt-out of converting
      identifiers to keywords
  :qualifier - optionally provides the namespace qualifier for identifiers
  :result-set-fn - applied to the entire result set, default doall / vec
      if :as-arrays? true, :result-set-fn will default to vec
      if :as-arrays? false, :result-set-fn will default to doall
  :row-fn - applied to each row as the result set is constructed, default identity
The second argument is a vector containing a SQL string or PreparedStatement, followed
by any parameters it needs.
See also prepare-statement for additional options.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/79ad004b42e9234d2bbf54df6a254c22b1c68c72/src/main/clojure/clojure/java/jdbc/datafy.clj#L142">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.java.jdbc.spec">clojure.java.jdbc.spec</h2>
<pre id="namespace-docstr">Optional specifications for use with Clojure 1.9 or later.</pre>


<br />



<div id="spec-section">
  <p></p>
  <h2>Specs</h2>
  <div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/as-arrays?">::as-arrays?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :as-is #{:cols-as-is} :truthy (nilable boolean?))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/auto-commit?">::auto-commit?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">boolean?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/classname">::classname</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/column-direction">::column-direction</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :id ::identifier :id-dir (map-of ::identifier ::direction))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/column-spec">::column-spec</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(cat
 :col ::identifier
 :spec (* (or :kw keyword? :str string? :num number?)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/concurrency">::concurrency</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(set (keys (deref #'result-set-concurrency)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/conditional?">::conditional?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :b boolean? :s string? :f fn?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/connection">::connection</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.sql.Connection %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/connection-binding">::connection-binding</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(cat :con-db simple-symbol? :db-spec any? :opts (? any?))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/connection-options">::connection-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [] :opt-un [::auto-commit? ::read-only?])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/connection-uri">::connection-uri</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/cursors">::cursors</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(set (keys (deref #'result-set-holdability)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/datasource">::datasource</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? javax.sql.DataSource %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec">::db-spec</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or
 :connection ::db-spec-connection
 :friendly ::db-spec-friendly
 :raw ::db-spec-raw
 :driver-mgr ::db-spec-driver-manager
 :factory ::db-spec-factory
 :datasource ::db-spec-data-source
 :jndi ::db-spec-jndi
 :uri-str ::db-spec-string
 :uri-obj ::db-spec-uri)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-connection">::db-spec-connection</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [::connection])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-data-source">::db-spec-data-source</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [::datasource] :opt-un [::username ::user ::password])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-driver-manager">::db-spec-driver-manager</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys
 :req-un [::subprotocol ::subname]
 :opt-un [::classname ::user ::password])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-factory">::db-spec-factory</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [::factory])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-friendly">::db-spec-friendly</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys
 :req-un [::dbtype ::dbname]
 :opt-un [::host ::port ::user ::password ::classname])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-jndi">::db-spec-jndi</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [::name] :opt-un [::environment])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-raw">::db-spec-raw</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [::connection-uri] :opt-un [::user ::password])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-string">::db-spec-string</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/db-spec-uri">::db-spec-uri</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.net.URI %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/dbname">::dbname</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/dbtype">::dbtype</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :alias ::subprotocol-alias :name ::subprotocol-base)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/delimiter">::delimiter</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :s string? :c char?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/direction">::direction</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">#{:desc "DESC" :asc "ASC" "desc" "asc"}</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/entities">::entities</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :s string?) :ret ::entity :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/entity">::entity</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/environment">::environment</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(nilable map?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/exec-sql-options">::exec-sql-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [] :opt-un [::entities ::transaction?])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/execute-options">::execute-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [] :opt-un [::transaction? ::multi? ::return-keys])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/execute-result">::execute-result</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(* integer?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/explain-fn">::explain-fn</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">fn?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/explain?">::explain?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :b boolean? :s string?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/factory">::factory</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :db-spec ::db-spec) :ret ::connection :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/fetch-size">::fetch-size</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">nat-int?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/find-by-keys-options">::find-by-keys-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys
 :req-un []
 :opt-un [::entities
          ::order-by
          ::result-set-fn
          ::row-fn
          ::identifiers
          ::qualifier
          ::keywordize?
          ::as-arrays?
          ::read-columns])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/host">::host</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/identifier">::identifier</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :kw keyword? :s string?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/identifiers">::identifiers</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :s ::entity) :ret ::identifier :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/isolation">::isolation</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(set (keys (deref #'isolation-levels)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/keywordize?">::keywordize?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">boolean?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/max-size">::max-size</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">nat-int?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/multi?">::multi?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">boolean?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/name">::name</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/naming-strategy">::naming-strategy</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :x ::identifier) :ret ::identifier :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/order-by">::order-by</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(coll-of ::column-direction)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/password">::password</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/port">::port</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :port pos-int? :s string?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/prepare-options">::prepare-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(merge
  (keys
   :req-un []
   :opt-un [::return-keys
            ::result-type
            ::concurrency
            ::cursors
            ::fetch-size
            ::max-rows
            ::timeout])
  ::connection-options)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/prepared-statement">::prepared-statement</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.sql.PreparedStatement %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/qualifier">::qualifier</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(nilable string?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/query-options">::query-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(merge
  (keys
   :req-un []
   :opt-un [::result-set-fn
            ::row-fn
            ::identifiers
            ::qualifier
            ::keywordize?
            ::as-arrays?
            ::read-columns])
  ::prepare-options)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/read-columns">::read-columns</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">fn?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/read-only?">::read-only?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">boolean?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/reducible-query-options">::reducible-query-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(merge
  (keys
   :req-un []
   :opt-un [::identifiers ::keywordize? ::qualifier ::read-columns])
  ::prepare-options)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/result-set">::result-set</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.sql.ResultSet %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/result-set-fn">::result-set-fn</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :rs (coll-of any?)) :ret any? :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/result-set-metadata">::result-set-metadata</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.sql.ResultSetMetaData %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/result-type">::result-type</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(set (keys (deref #'result-set-type)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/return-keys">::return-keys</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :columns (coll-of ::entity :kind vector?) :boolean boolean?)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/row-fn">::row-fn</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(fspec :args (cat :row (map-of keyword? ::sql-value)) :ret any? :fn nil)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/sql-params">::sql-params</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or
 :sql ::sql-stmt
 :sql-params (cat :sql ::sql-stmt :params (* ::sql-value)))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/sql-stmt">::sql-stmt</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(or :sql string? :stmt ::prepared-statement)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/sql-value">::sql-value</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">any?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/subname">::subname</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/subprotocol">::subprotocol</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/subprotocol-alias">::subprotocol-alias</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">#{"mssql" "oracle" "postgres" "jtds" "hsql"}</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/subprotocol-base">::subprotocol-base</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">#{"h2:mem"
  "mysql"
  "oracle:thin"
  "pgsql"
  "oracle:oci"
  "postgresql"
  "sqlite"
  "h2"
  "jtds:sqlserver"
  "hsqldb"
  "redshift"
  "derby"
  "sqlserver"}</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/table-spec">::table-spec</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/timeout">::timeout</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">nat-int?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/transaction-binding">::transaction-binding</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(cat :t-con simple-symbol? :db-spec any? :opts (? any?))</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/transaction-options">::transaction-options</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(keys :req-un [] :opt-un [::isolation ::read-only?])</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/transaction?">::transaction?</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">boolean?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/uri">::uri</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(instance? java.net.URI %)</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/user">::user</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/username">::username</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">string?</pre>
  </div><div id="spec-entry">
    <br />
    <hr />
    <h2 id=":clojure.java.jdbc.spec/where-clause">::where-clause</h2>
    <span id="spec-type">spec</span><br />
    <pre id="spec-description">(cat :where string? :params (* ::sql-value))</pre>
  </div>
</div>

</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>